# n-Bit Universal Shift Register
This project give overview of RTL to GDSII of universal shift register using OpenLane and Skywater130 PDK. OpenLane is an automated open-source EDA tool which gives RTL to GDSII flow. 

![usr_1bit](https://user-images.githubusercontent.com/63975346/142893103-e208d580-2bd2-4e43-b369-9cc11f55f1f2.png)


This is 1-bit Universal Shift Register, written using Flip-Flop with case statement (universal_shift_register_1bit). 
| Select Line | Function |
|     :---:   |     :---:   |
| 00 | Memory State |
| 01 | LeftIn |
| 10 | RightIn |
| 00 | Parallel Input |



This is n-bit Universal Shift Register.

The `usr_nbit.v` contain 2 module `universal_shift_register_1bit` and `usr_nbit`. `usr_nbit` is the instantiated module of `universal_shift_register_1bit`, with variable size. The parameter size can be changed as per requirements. In this example I used `size=4` which means 4 bit universal shift register.

`usr_nbit_tb.v` is test bench for `usr_nbit.v` with following values for corresponding time.

Test bench in Tabular format.
Here, `clk period = 2ns`, `LeftIn = 1`, `RightIn = 1` 

| Time (ns) | Reset |Select Line | ParalleIn | ParallelOut | 
| :---: | :---: |:---: | :---: | :---: |
| 0 | x | xx | xxxx | xxxx |
| 1 | 1 | 00 | 0000 | xxxx |
| 2 | 1 | 00 | 0000 | 0000 |
| 3 | 1 | 00 | 0000 | 0000 |
| 4 | 1 | 00 | 0000 | 0000 |
| 5 | 0 | 00 | 0000 | 0000 |
| 6 | 0 | 00 | 0000 | 0000 |
| 7 | 0 | 00 | 0000 | 0000 |
| 8 | 0 | 00 | 0000 | 0000 |
| 9 | 0 | 11 | 0110 | 0000 |
| 10 | 0 | 11 | 0110 | 0110 |
| 11 | 0 | 11 | 0110 | 0110 |
| 12 | 0 | 11 | 0110 | 0110 |
| 13 | 0 | 00 | 1010 | 0110 |
| 14 | 0 | 00 | 1010 | 0110 |
| 15 | 0 | 00 | 1010 | 0110 |
| 16 | 0 | 00 | 1010 | 0110 |
| 17 | 0 | 01 | 1010 | 0110 |
| 18 | 0 | 01 | 1010 | 1011 |
| 19 | 0 | 01 | 1010 | 1011 |
| 20 | 0 | 01 | 1010 | 1011 |
| 21 | 0 | 10 | 1010 | 1011 |
| 22 | 0 | 10 | 1010 | 0111 |
| 23 | 0 | 10 | 1010 | 0111 |
| 24 | 0 | 10 | 1010 | 0111 |
| 25 | 0 | 00 | 0001 | 0111 |
| 26 | 0 | 00 | 0001 | 0111 |
| 27 | 0 | 00 | 0001 | 0111 |
| 28 | 0 | 00 | 0001 | 0111 |
| 29 | 0 | 01 | 1010 | 0111 |
| 30 | 0 | 01 | 1010 | 1011 |
| 31 | 0 | 01 | 1010 | 1011 |


*The below figure is waveform from `GTKWAVE` generated by `iverilog`.*
![tb_wave](https://user-images.githubusercontent.com/63975346/142893792-d2aba94b-d1d5-41e2-96e0-f513baf5fac9.PNG)


I modified the netlist generated after synthesis (`usr_nbit.synthesis.v`) and verified using iverilog. Below figure is waveform from `GTKWAVE` generated by `iverilog`.

![tb_wave_after_synth](https://user-images.githubusercontent.com/63975346/142900601-8cf55e84-14fe-4403-8acb-b41f88e2e04c.PNG)

# OpenLane Flow

| Index  | Input | Function | Output |
|     :---:      |     :---:      |     :---:      |     :---:      |
| Prep  | `sky130`(PDK)\, `sky130_fd_sc_hd`(Std cell Library)\, `LEF's` | Prepare LEF files\, Extract metal layers from `.tlef.`\, Merging LEF's\, Trimming Liberty | Preparation complete  |
| Index1  | `src/usr_nbit.v`  | Optimize the design and remove unused part of design, Find no. of gates required and map corresponding gates fron PDK. Generate Graphviz representation of design\, Generate synthesis stats.   | `usr_nbit.synthesis.v` \, `hierarchy.dot` |
| Index2  | `merged_unpadded.lef`\, `usr_nbit.synthesis.v`\, `sky130_fd_sc_hd__ss_100C_1v60.lib`\, ` sky130_fd_sc_hd__ff_n40C_1v95.lib` | Set input and output delay to 2.00\, Static Timing Analysis (STA)\, Generate STA report.   | `2-opensta.min_max.rpt`  |
| Index3  | `usr_nbit.synthesis.v`\, `merged_unpadded.lef`\, Synthesis Report | Generate Floorplan report(core area,die area).  | `3-verilog2def_openroad.def`  |
| Index4  | `3-verilog2def_openroad.def`\, `merged.lef` | Create pins & components-terminal with default 5u boundaries offset  | `4-ioPlacer.def`  |
| Index5  | `4-ioPlacer.def`\, `merged_unpadded.lef` | Insert Tap/Decap cells  | `4-ioPlacer.def`  |
| Index4 | `merged.lef`\, `3-verilog2def_openroad.def` | IO Placement\, Random pin placement with default 5u boundaries offset | `4-ioPlacer.def` |
| Index5 | `merged_unpadded.lef`\, `4-ioPlacer.def` | Tap and Decap cell insertion | `usr_nbit.floorplan.def` |
| Index6 | `sky130A.lyt`\, `usr_nbit.floorplan.def` | Screenshot using `sky130.lyt` and layout. | `usr_nbit.floorplan.def.png` |
| Index7 | `merged_unpadded.lef`\, `usr_nbit.floorplan.def`\, `common_pdn.tcl` |Power planning\, met1 used as Stdcell Rails\, met4 and met5 used as Straps for PDN | `7-pdn.def` |
| Index8 | `merged_unpadded.lef`\, `7-pdn.def`|Global placement using `7-pdn.def`\, Running Resizer Design Optimizations\, Design Stats and Placement Analysis. | `8-replace.def `\, `8-resizer.def` |
| Index9 | `merged_unpadded.lef`\, `8-resizer.def`| Writing Verilog using `8-resizer.def`. |  `usr_nbit.synthesis_optimized.v` |
| Index10 | `merged_unpadded.lef`\, `usr_nbit.synthesis_optimized.v`\, ` sky130_fd_sc_hd__ss_100C_1v60.lib`\, ` sky130_fd_sc_hd__ff_n40C_1v95.lib` | Static Timing Analysis (STA)\, Generate STA Report. | `10-opensta_post_resizer.min_max.rpt` |
| Index11 | `merged_unpadded.lef`\, `8-resizer.def` | Detailed Placement. Design Stats and Placement Analysis. | `usr_nbit.placement.def` | 
| Index12 | `sky130A.lyt`\, `usr_nbit.placement.def` | Screenshot using `sky130.lyt` and layout. | `usr_nbit.placement.def.png` |
| Index13 | `merged_unpadded.lef`\, `usr_nbit.placement.def` | Create Characterization and compile LUT, build clock tree using **H-Tree** Topology. Repairing long wires on clock nets. Design Stats and Placement Analysis. | `usr_nbit.cts.def` |
| Index14 | `merged_unpadded.lef`\, `usr_nbit.cts.def` | Writing Verilog using `usr_nbit.cts.def`. | `usr_nbit.synthesis_cts.v` |
| Index15 | `sky130A.lyt`\, `usr_nbit.cts.def` | Screenshot using `sky130.lyt` and layout. Running Resizer Timing Optimization\, Design Stats and Placement Analysis. | `usr_nbit.cts.def.png`\, ` 15-resizer_timing.def` |
| Index16 | `merged_unpadded.lef`\, `15-resizer_timing.def ` | Writing Verilog using `15-resizer_timing.def`. | `usr_nbit.synthesis_optimized.v` |
| Index17 | `merged_unpadded.lef`\, `usr_nbit.synthesis_optimized.v`\, ` sky130_fd_sc_hd__ss_100C_1v60.lib`\, ` sky130_fd_sc_hd__ff_n40C_1v95.lib` | Static Timing Analysis (STA)\, Generate STA Report. | `17-opensta_post_resizer.min_max.rpt` |
| Index18 | `merged_unpadded.lef`\, `15-resizer_timing.def ` | Global Routing using `15-resizer_timing.def` with Maze Routing Topology\, Generate Routing report | `18-fastroute.def`\, `18-fastroute.guide` |
| Index19 | `merged_unpadded.lef`\, `18-fastroute.def` | Fill Instance Insertion | `19-addspacers.def` |
| Index20 | `merged_unpadded.lef`\, `19-addspacers.def` | Writing Verilog using `19-addspacers.def`. | `usr_nbit.synthesis_preroute.v` |
| Index21 | `merged_unpadded.lef`\, `19-addspacers.def `\, `18-fastroute.guide` | Running Detailed Routing\, Optimize detailed routing\, Generate report. | `usr_nbit.def` |
| Index22 | `sky130A.lyt`\, ` usr_nbit.def` | Screenshot using `sky130.lyt` and layout. | `usr_nbit.def.png` |
| Index23 | `usr_nbit.def` | Parsing LEF and DEF files\, SPEF extraction. | `usr_nbit.spef` |
| Index24 | `merged_unpadded.lef`\, `usr_nbit.synthesis_preroute.v`\, `sky130_fd_sc_hd__ss_100C_1v60.lib`\, ` sky130_fd_sc_hd__ff_n40C_1v95.lib` | Static Timing Analysis (STA)\, Generate STA Report. | `24-opensta_post_resizer.min_max.rpt` |
| Index25 | `merged.lef`\, `usr_nbit.def` | Writing Powered Verilog using `usr_nbit.def`. | `25-add_sub2.powered.def` |
| Index26 | `merged_unpadded.lef`\, `25-usr_nbit.powered.def` | Writing Verilog using `25-usr_nbit.powered.def`. | `usr_nbit.lvs.powered.v` |
| Index27 | `.magicrc`\, `mag_gds.tcl`\, `sky130_fd_sc_hd.tlef`\, `usr_nbit.def` | Streaming out GDS II using Magic | `usr_nbit.gds` |
| Index28 | `sky130A.lyt`\, `usr_nbit.gds` | Screenshot using `sky130.lyt` and magic layout. | `usr_nbit.gds.png` |
| Index29 | `.magicrc`\, `gds_pointers.tcl` | Report Properties of GDS II. | `magic_gds_ptrs.mag` |
| Index30 | `.magicrc`\, `lef.tcl`\, `sky130_fd_sc_hd.tlef` | Writing abstract LEF. | `usr_nbit.lef` |
| Index31 | `.magicrc`\, ` usr_nbit.lef`\, ` maglef.tcl` | Generating MAGLEF using `usr_nbit.lef`. | ` usr_nbit.lef .mag` |
| Index27 | `.magicrc`\, `mag_gds.tcl`\, `sky130_fd_sc_hd.tlef`\, `usr_nbit.def` | Streaming out GDS II using Klayout | `usr_nbit.gds` |
| Index33 | `sky130A.lyt`\, `usr_nbit.gds` | Screenshot using `sky130.lyt` and klayout. | `usr_nbit.gds.png` |
| Index34 | `magic/usr_nbit.gds`\, `klayout/usr_nbit.gds` | Running XOR on layout using Klayout. | `usr_nbit.xor.gds` |
| Index35 | `sky130A.lyt`\, `usr_nbit.xor.gds` | Screenshot using `sky130.lyt` and layout. | `usr_nbit.xor.gds.png` |
| Index36 | `magic/usr_nbit.gds`\, `klayout/usr_nbit.gds` | Running XOR on layout using Klayout and generate xml file. | `usr_nbit.xor.xml` |
| Index37 | `.magicrc`\, `magic_spice.tcl`\, `sky130_fd_sc_hd.tlef`/, `usr_nbit.def` | Running Magic Spice Export from LEF. | `usr_nbit.spice` |
| Index38 | `usr_nbit.spice`\, `usr_nbit.lvs.powered.v`\, `sky130A_setup.tcl` | Running LEF LVS\, Generate LVS log. | `usr_nbit.lvs.lef.log` |
| Index39 | `.magicrc`\, `drc.tcl` | Running Magic DRC | `39-magic.drc`\, `usr_nbit.drc.mag` |
| Index40 | `merged_unpadded.lef`\, `usr_nbit.def` | Running Antenna Checks using OpenRoad Antenna rule checker | `41-antenna-rpt` |
| Index41 | `merged_unpadded.lef`\, `usr_nbit.def` | Circuit Validation Check | `cvc_usr_nbit.log`\, `cvc_usr_nbit.error.gz`\, `cvc_usr_nbit.debug.gz` |
| Index42 | `cvcrc.sky130A`\, `usr_nbit.cdl`\, `cvc_usr_nbit.log` | Generating Final Summary Report | `final_summary_report.csv` |


# OpenLane VLSI Design Execution.
`flow.tcl -design <design> -src <verilog file path> -init_design_config`. This code prepare design for execution.

# Non-Interactive Mode
`flow.tcl -design <design> -tag <tag>`. This is automated execution of Design from RTL to GDS II. 

# Interactive Mode
`flow.tcl -design <design> -tag <tag> -interactive`. This is user friendly, manual execution of tools from RTL to GDS II.

| Code | Corresponding Index |
 |     :---:      |     :---:      |
| `run_synthesis` | Index1 – Index2 |
| `run_floorplan` | Index3 – Index7 |
| `run_placement` | Index8 – Index12 |
| `run_cts` | Index13 – Index15 (Screenshot) |
| `run_resizer_timing` | Index15(Resizer) – Index17 |
| `run_routing`| Index18 – Index24 |
| `write_powered_verilog` | Index25 – Index26 |
| `set_netlist $::env(lvs_result_file_tag).powered.v` | set variable to write Verilog. |
| `run_magic` | Index27 – Index31 |
| `run_klayout` | Index32 – Index33 |
| `run_klayout_gds_xor` | Index34 – Index36 |
| `run_magic_spice_export` | Index37 |
| `run_lvs` | Index38 |
| `run_magic_drc` | Index39 |
| `run_klayout_drc` | |
| `run_antenna_check` | Index40 |
| `run_lef_cvc` | Index41 – Index42 |
| `calc_total_runtime` | |
| `generate_final_summary_report` | |

 # Synthesis
`Yosys`, is a Verilog RTL synthesis framework that generates gate level netlist from verilog code and `abc` performs technology mapping. The resulting netlist is used by the `OpenSTA`  tool for static timing analysis, generating timing reports. OpenLane EDA tool comes with different synthesis scripts, Synthesis Exploration helps in picking the best synthesis strategy which will provide a netlist functionally same as input design.
 
*Graphviz representation of design.*
![#1 usr_hs](https://user-images.githubusercontent.com/63975346/142900991-93ffb20e-5036-44e0-aa2e-be6fdd5a7d5d.png)

# Floorplan
For Good placement, the most important value would be `FP_CORE_UTIL` (area occupied by the standard cells, macros, and other cells), `FP_ASPECT_RATIO` (This ratio is determined by the horizontal routing resources to vertical routing resources (or) height/width). Before we proceed with floor planning, we need to ensure that all inputs we need for the floorplan are prepared properly. Because it deals with placement of I/O pads, macros, power, and ground structure. In addition to the macros core area, its rows (which is essential during placement) and its tracks (which is essential during routing) are defined by `init_fp` Macro inputs and outputs ports are placed by `ioplacer` and the `pdn` tool generates the power distribution network. `tapcell` tool used to insert `welltap` and `decap` cells in the floorplan.
 
 `usr_nbit` Floorplan The visible structure is tapcells and decap cells.
 At bottom there are Stdcells which are need to be placed.
 
 ![#2 fp](https://user-images.githubusercontent.com/63975346/142964537-f43b7af7-e801-47a2-897a-151d36964ba2.PNG)
 
 This is io Placement viewed using Klayout.
 
 ![#3 io](https://user-images.githubusercontent.com/63975346/142964860-d0f4584f-bf22-4469-bd4e-e6117260480c.png)

 Power Network Distribution.
 
 ![#4 pdn](https://user-images.githubusercontent.com/63975346/142965040-ad9944ff-05b2-4cb1-88cc-fdc1ff9b44a1.PNG)


# Placement
Core area and rows of macros were determined in Floorplanning. The role of placement is to determine the locations of standard cells present in the netlist by placing these standard cells inside the core area of IC. A logical representation of the cells is in the Netlist. A tool places cells at the desired location based on the physical location of cells in LEF. Placement of cells is most important and challenging, because good placement minimises area and also ensures good routing. Lib file contains a number of the same kind of cells, so the tool picks the cell considering logic present in netlist and input constraints.
The most important configure parameter for placement is `PL_TARGET_DESNSITY` which describes how close or how far cells are from each other and is easy to set. `PL_TARGET_DESNSITY` ranges from 0.0 to 1.0. It is the measure of how widely the cells would spread throughout the core area. The `RePLace` tool performs global placement. Resizer tool performs optional optimizations on the design. The `OpenPhySyn` tool performs timing optimizations on the design. `OpenDP` this tool legalizes global components by performing detailed placement.
 
 Global Placement
 
 ![#6 gb placement](https://user-images.githubusercontent.com/63975346/142964947-4fbd4f26-38e2-408c-adb8-715a7c496f14.PNG)

 Detailed Placement
 
 ![#7 placement](https://user-images.githubusercontent.com/63975346/142964968-3ace609a-0155-422e-b7fa-a63b073ab20a.PNG)

 

# Clock Tree Synthesis
Clock Tree Synthesis ensures that all of the clock signals in a design are distributed evenly to all sequential circuits in a design. In CTS, skew and latency are minimized. The clock tree constraints and the placement data will be given as input to CTS. Output of CTS are Latency and skew report. CTS def, timing report and clock structure report is also generated after CTS. Clock tree building and clock tree balancing are done by CTS. `TritonCTS` tool is used to synthesize the clock distribution network (the clock tree). `TritonCTS` uses H-Tree Toplogy.

 # Routing 
After CTS, routing is the stage at which the necessary interconnections are determined by finding the exact paths for each network. By the end of CTS, the tool will know the locations of cells, pins, IO ports, and pads. The logical connectivity and design rules are defined by netlist and technology files respectively and are available to the tool. Routing is the process after CTS in which interconnection of the macro pins, the standard cells, the pins of the block boundary, the pads of the chip boundary using technology files. All connections defined by the netlist are electrically connected using metal and vias in the routing stage. So, basically, routing is allocating a set of metal layers (wires) in the routing space that makes interconnections between all the nets in the netlist by ensuring certain design rules for the metals and vias. `FastRoute` tool performs global routing to generate a guide file for the detailed router. `CU-GR` is another option for performing global routing. The `TritonRoute` tool performs detailed routing. `SPEF-Extractor`, performs SPEF extraction.

# Design Checks
DRC checks are performed using `Magic` and `Klayout`. LVS Checks are performed using `Netgen`. Antenna Checks are performed by `Magic` and `CVC` performs Circuit Validity Checks.

# GDS II Generation 
After OpenLane execution the main outputs of the flow, are mainly GDSII and LEF views, which can be used in bigger designs and by foundry. `Magic` tool is used to stream out the final GDSII layout file from the routed def. `Klayout` tool is used to stream out the final GDSII layout file from the routed def as a back-up.

# Conclusion
We overviewed the key components of OpenLane, the only open-source EDA tool which is automated for manufacturing IC’s. We overviewed how OpenLane combines logic synthesis, placement and routing, as well as physical verification, with a manufacturing-ready open process development kit (PDK), we saw how EDA Tool practically performs IC design flow. OpenLane provides us to configure parameters by which optimal config for design can be found. It also has an option for regression run and various parameters can be compared. We executed RTL to GDSII Flow of 4-bit universal shift register. The final goal of our overall work is to understand VLSI design flow with a practical approach using the EDA tool. We can achieve 0 negative slack by varying various configuration parameters and changing clock period. Currently, OpenLane is the only open-source flow developed by Google and SkyWater which can be readily used to almost fully automate chip integration for the open PDK. This tool is useful for students who need practical experience in chip design.

# References
[1] `“OpenLANE”` https://github.com/The-OpenROAD-Project/OpenLane

[2] `“SkyWater SKY130 PDK,”` https://skywater-pdk.readthedocs.io

[3] Ahmed Alaa Ghazy, and Mohamed Shalan Efabless Corporation, San Jose, USA, “OpenLANE: The Open-Source Digital ASIC Implementation Flow”

[4] `“LEF Technology file,”` https://youtu.be/OXrLdlz_4CM

[5] `“DEF Technology file,”` https://youtu.be/Ze9Mc6j8nFY

[6] `“LIB Technology file,”` https://youtu.be/0rFoqV8L0GM

[7] `“Yosys,”` https://github.com/YosysHQ/yosys

[8] `“OpenSTA,”` https://github.com/The-OpenROAD-Project/OpenSTA

[9] `“Fault,”` https://github.com/Cloud-V/Fault

[10] `“Design Flow,”` https://www.vlsiguide.com/search/label/Physical%20Design%20Flow

[11] `“TritonRoute,”` https://github.com/The-OpenROAD-Project/TritonRoute

[12] `“SPEF_EXTRACTOR,”` https://github.com/HanyMoussa/SPEF_EXTRACTOR

[13] `“Magic VLSI,”` https://github.com/RTimothyEdwards/magic

[14] `“KLayout,”` https://github.com/KLayout/klayout

[15] `OpenLane Overview` https://youtu.be/d0hPdkYg5QI

[16] `“OpenLANE Output,”` https://openlane.readthedocs.io/en/latest/#openlane-output

[17] `“Config Parameters,”` https://openlane.readthedocs.io/en/develop/configuration/README.html


# Acknowledgment
I am extremely thankful to Dr. Ramesh Kini M Associate Professor NITK, Surathkal for sharing expertise, valuable guidance and encouragement and also providing this wonderful Internship opportunity to me.
